/*
 * generated by Xtext 2.12.0
 */
package iDM_Test.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import iDM_Test.StateMachine
import iDM_Test.State
import fr.inria.diverse.k3.al.annotationprocessor.Aspect
import fr.inria.diverse.k3.al.annotationprocessor.Step
import iDM_Test.Transition

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class StateMachineGenerator extends AbstractGenerator {
	
	var StateMachine stateMachine
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		this.stateMachine = resource.contents.get(0) as StateMachine
		fsa.generateFile(stateMachine.name.toFirstUpper() + ".java", stateMachineClass)
		fsa.generateFile("State.java", stateClass)
	}
	
	def getStateMachineClass() {
		'''
		import State;
		import Transition;
		import java.util.ArrayList;
		import java.util.List;
		
		public class «stateMachine.name.toFirstUpper()» {
			
			private String name;
			private State initState;
			private List<State> stateList;
			private List<Transition> transitionList;
			
			public «stateMachine.name.toFirstUpper()»(State init) {
				this.name = «stateMachine.name.toFirstUpper()»;
				this.initState = init;
				this.stateList = new ArrayList<State>();
				this.transitionList = new ArrayList<Transition>();
			}
			
			public String getName(){
				return this.name;
			}
			
			public State getInitState(){
				return this.initState;
			}
			
			public List<State> getStateList(){
				return this.stateList;
			}
			
			public void addState(State newState){
				this.stateList.add(newState);
			}
			
			public List<Transition> getTransitionList(){
				return this.transitionList;
			}
			
			public void addtransition(Transition newTransition){
				this.transitionList.add(newTransition);
			}
		}
		'''
	}
	
	def stateClass() {
		'''
		package states;
		import Transition;
		import java.util.ArrayList;
		import java.util.List;
		
		public class State {
			
			private String name;
			private List<Transition> incoming;
			private List<Transition> outgoing;
			
			public State(String name){
				this.name = name;
				this.incomimng = new ArrayList<Transition>();
				this.outgoing =  new ArrayList<Transition>();
			}
			
			public String getName(){
				return this.name;
			}
			
			public List<Transition> getIncoming(){
				return this.incomimng;
			}
			
			public void addIncoming(Transition newIncoming) {
				this.incomimng.add(newIncoming);
			}
			
			public List<Transition> getOutgoing(){
				return this.outgoing;
			}
			
			public void addOutgoing(Transition newOutgoing) {
				this.outgoing.add(newOutgoing);
			}
		}
		'''
	}

}

	
@Aspect(className=State)
class StateAspect {
	@Step
	def public void step(String inputString) {
		// Get the valid transitions	
		val validTransitions = _self.outgoing.filter[t|inputString.compareTo(t.trigger) == 0]

		if (validTransitions.empty) {
			// just copy the token to the output buffer
			_self.fsm.outputBuffer.enqueue(inputString)
		}

		if (validTransitions.size > 1) {
			throw new Exception("Non Determinism")
		}

		// Fire transition first transition (could be random%VT.size)
		if (validTransitions.size > 0) {
			validTransitions.get(0).fire
			return
		}
		return

	}
}
    
@Aspect(className=Transition)
class TransitionAspect {
	@Step
	def public void fire() {
		println("Firing " + _self.name + " and entering " + _self.to.name)
		val fsm = _self.from.fsm
		fsm.currentState = _self.to
		fsm.outputBuffer.enqueue(_self.action)
		fsm.consummedString = fsm.consummedString + fsm.underProcessTrigger
	}
}
